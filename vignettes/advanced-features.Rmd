---
title: "Advanced Features and Customization"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced Features and Customization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

# Advanced Features and Customization

This vignette covers advanced ZZedc features including custom modules, API integration, advanced security, and enterprise deployment options.

## Overview

Advanced ZZedc features include:

- Custom module development
- API endpoints and integration
- Advanced security and compliance
- Custom validation rules
- Enterprise deployment
- Performance optimization
- Integration with external systems

## Prerequisites

```{r setup}
library(zzedc)
library(shiny)
library(DT)
library(dplyr)
library(config)
library(pool)
library(httr)
library(jsonlite)
```

## Custom Module Development

### Creating Custom Modules

ZZedc uses a modular architecture that allows custom functionality:

```{r custom_module}
# Example custom module for pharmacokinetics data
pk_module_ui <- function(id) {
  ns <- NS(id)

  tagList(
    fluidRow(
      column(12,
        h3("Pharmacokinetics Data Entry"),

        # Sample collection information
        wellPanel(
          h4("Sample Collection"),
          fluidRow(
            column(4,
              dateInput(ns("collection_date"), "Collection Date")
            ),
            column(4,
              timeInput(ns("collection_time"), "Collection Time")
            ),
            column(4,
              selectInput(ns("sample_type"), "Sample Type",
                         choices = c("Plasma", "Serum", "Urine", "Saliva"))
            )
          )
        ),

        # Concentration data
        wellPanel(
          h4("Concentration Results"),
          fluidRow(
            column(6,
              numericInput(ns("concentration"), "Concentration (ng/mL)",
                          value = NULL, min = 0)
            ),
            column(6,
              selectInput(ns("assay_method"), "Assay Method",
                         choices = c("LC-MS/MS", "ELISA", "RIA"))
            )
          ),

          fluidRow(
            column(6,
              numericInput(ns("lloq"), "LLOQ (ng/mL)",
                          value = NULL, min = 0)
            ),
            column(6,
              checkboxInput(ns("below_lloq"), "Below LLOQ")
            )
          )
        ),

        # Quality control
        wellPanel(
          h4("Quality Control"),
          fluidRow(
            column(6,
              selectInput(ns("analyst"), "Analyst",
                         choices = c("Analyst 1", "Analyst 2", "Analyst 3"))
            ),
            column(6,
              dateInput(ns("analysis_date"), "Analysis Date")
            )
          ),

          textAreaInput(ns("comments"), "Comments", rows = 3)
        ),

        # Action buttons
        fluidRow(
          column(12,
            actionButton(ns("save_data"), "Save PK Data", class = "btn-primary"),
            actionButton(ns("validate_data"), "Validate", class = "btn-warning"),
            actionButton(ns("clear_form"), "Clear Form", class = "btn-secondary")
          )
        )
      )
    ),

    # Data display
    fluidRow(
      column(12,
        h4("Existing PK Data"),
        DT::dataTableOutput(ns("pk_data_table"))
      )
    )
  )
}

pk_module_server <- function(id) {
  moduleServer(id, function(input, output, session) {

    # Reactive values for data storage
    pk_data <- reactiveVal(data.frame(
      subject_id = character(),
      collection_date = as.Date(character()),
      collection_time = character(),
      sample_type = character(),
      concentration = numeric(),
      assay_method = character(),
      lloq = numeric(),
      below_lloq = logical(),
      analyst = character(),
      analysis_date = as.Date(character()),
      comments = character(),
      stringsAsFactors = FALSE
    ))

    # Data validation function
    validate_pk_data <- function() {
      errors <- c()

      if (is.null(input$collection_date) || is.na(input$collection_date)) {
        errors <- c(errors, "Collection date is required")
      }

      if (is.null(input$concentration) || is.na(input$concentration)) {
        if (!input$below_lloq) {
          errors <- c(errors, "Concentration required if not below LLOQ")
        }
      }

      if (input$below_lloq && !is.null(input$concentration) && !is.na(input$concentration)) {
        if (input$concentration >= input$lloq) {
          errors <- c(errors, "Concentration should be below LLOQ if 'Below LLOQ' is checked")
        }
      }

      return(errors)
    }

    # Save data event
    observeEvent(input$save_data, {
      validation_errors <- validate_pk_data()

      if (length(validation_errors) > 0) {
        showModal(modalDialog(
          title = "Validation Errors",
          HTML(paste(validation_errors, collapse = "<br>")),
          easyClose = TRUE,
          footer = modalButton("OK")
        ))
        return()
      }

      # Add new record
      new_record <- data.frame(
        subject_id = "CURRENT_SUBJECT", # Would get from session
        collection_date = input$collection_date,
        collection_time = format(input$collection_time, "%H:%M"),
        sample_type = input$sample_type,
        concentration = ifelse(input$below_lloq, NA, input$concentration),
        assay_method = input$assay_method,
        lloq = input$lloq,
        below_lloq = input$below_lloq,
        analyst = input$analyst,
        analysis_date = input$analysis_date,
        comments = input$comments,
        stringsAsFactors = FALSE
      )

      current_data <- pk_data()
      updated_data <- rbind(current_data, new_record)
      pk_data(updated_data)

      showNotification("PK data saved successfully", type = "success")
    })

    # Clear form event
    observeEvent(input$clear_form, {
      updateDateInput(session, "collection_date", value = NA)
      updateNumericInput(session, "concentration", value = NA)
      updateTextAreaInput(session, "comments", value = "")
      # Reset other inputs...
    })

    # Render data table
    output$pk_data_table <- DT::renderDataTable({
      DT::datatable(pk_data(),
                    options = list(scrollX = TRUE, pageLength = 10),
                    class = 'cell-border stripe hover')
    })
  })
}
```

### Integrating Custom Modules

```{r integrate_module}
# Add custom module to main application
# In ui.R:
custom_ui_integration <- function() {
  nav_panel("Pharmacokinetics",
    pk_module_ui("pk_module")
  )
}

# In server.R:
custom_server_integration <- function(input, output, session) {
  pk_module_server("pk_module")
}
```

## API Development

### Creating REST API Endpoints

```{r api_endpoints}
# Custom API endpoints for external integration
create_api_endpoints <- function() {

  # Endpoint for subject data retrieval
  get_subject_data <- function(subject_id) {
    # Database query
    query <- "SELECT * FROM subjects WHERE subject_id = ?"
    result <- pool::dbGetQuery(db_pool, query, params = list(subject_id))

    if (nrow(result) == 0) {
      return(list(
        status = "error",
        message = "Subject not found",
        data = NULL
      ))
    }

    return(list(
      status = "success",
      data = result
    ))
  }

  # Endpoint for data submission
  submit_external_data <- function(data_payload) {
    # Validate incoming data
    validation_result <- validate_external_data(data_payload)

    if (!validation_result$valid) {
      return(list(
        status = "error",
        message = "Validation failed",
        errors = validation_result$errors
      ))
    }

    # Insert into database
    tryCatch({
      pool::dbExecute(db_pool,
        "INSERT INTO external_data (subject_id, data_type, data_value, timestamp) VALUES (?, ?, ?, ?)",
        params = list(
          data_payload$subject_id,
          data_payload$data_type,
          data_payload$data_value,
          Sys.time()
        )
      )

      return(list(
        status = "success",
        message = "Data submitted successfully"
      ))

    }, error = function(e) {
      return(list(
        status = "error",
        message = paste("Database error:", e$message)
      ))
    })
  }

  # Endpoint for study statistics
  get_study_statistics <- function() {
    stats_query <- "
      SELECT
        COUNT(*) as total_subjects,
        COUNT(CASE WHEN status = 'Active' THEN 1 END) as active_subjects,
        COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed_subjects,
        AVG(age) as mean_age
      FROM subjects
    "

    result <- pool::dbGetQuery(db_pool, stats_query)

    return(list(
      status = "success",
      data = result
    ))
  }

  list(
    get_subject = get_subject_data,
    submit_data = submit_external_data,
    get_stats = get_study_statistics
  )
}

# Example API client code
api_client_example <- function() {

  # Function to call ZZedc API
  call_zzedc_api <- function(endpoint, method = "GET", data = NULL) {
    base_url <- "http://localhost:3838/api"
    url <- paste0(base_url, "/", endpoint)

    if (method == "GET") {
      response <- httr::GET(url)
    } else if (method == "POST") {
      response <- httr::POST(url,
                            body = jsonlite::toJSON(data),
                            encode = "json",
                            httr::add_headers("Content-Type" = "application/json"))
    }

    content <- httr::content(response, "text")
    return(jsonlite::fromJSON(content))
  }

  # Example usage
  subject_data <- call_zzedc_api("subject/STUDY001")
  study_stats <- call_zzedc_api("statistics")

  # Submit external data
  external_data <- list(
    subject_id = "STUDY001",
    data_type = "laboratory",
    data_value = "hemoglobin:12.5"
  )

  submission_result <- call_zzedc_api("submit", "POST", external_data)
}
```

## Advanced Security Features

### Enhanced Authentication

```{r advanced_auth}
# Multi-factor authentication setup
setup_mfa <- function() {

  # TOTP (Time-based One-Time Password) integration
  generate_totp_secret <- function(user_id) {
    # Generate base32 secret for TOTP
    secret <- base32encode(openssl::rand_bytes(20))

    # Store in secure database
    pool::dbExecute(db_pool,
      "UPDATE users SET totp_secret = ? WHERE user_id = ?",
      params = list(secret, user_id)
    )

    return(secret)
  }

  # Verify TOTP token
  verify_totp <- function(user_id, token) {
    # Retrieve user's secret
    secret_query <- "SELECT totp_secret FROM users WHERE user_id = ?"
    result <- pool::dbGetQuery(db_pool, secret_query, params = list(user_id))

    if (nrow(result) == 0 || is.na(result$totp_secret)) {
      return(FALSE)
    }

    # Generate current valid tokens (allowing for time drift)
    current_time <- as.numeric(Sys.time()) %/% 30
    valid_tokens <- sapply((current_time - 1):(current_time + 1), function(t) {
      generate_totp_token(result$totp_secret, t)
    })

    return(token %in% valid_tokens)
  }

  # Enhanced login process
  enhanced_login <- function(username, password, totp_token = NULL) {
    # Standard password verification
    auth_result <- authenticate_user(username, password)

    if (!auth_result$success) {
      return(auth_result)
    }

    # Check if MFA is required
    mfa_query <- "SELECT mfa_enabled FROM users WHERE username = ?"
    mfa_result <- pool::dbGetQuery(db_pool, mfa_query, params = list(username))

    if (mfa_result$mfa_enabled && is.null(totp_token)) {
      return(list(
        success = FALSE,
        message = "MFA token required",
        mfa_required = TRUE
      ))
    }

    if (mfa_result$mfa_enabled && !verify_totp(auth_result$user_id, totp_token)) {
      return(list(
        success = FALSE,
        message = "Invalid MFA token"
      ))
    }

    return(auth_result)
  }
}

# Role-based access control
advanced_rbac <- function() {

  # Define granular permissions
  permissions <- list(
    data_entry = c("enter_data", "edit_own_data"),
    data_review = c("view_all_data", "generate_queries"),
    data_management = c("view_all_data", "edit_all_data", "resolve_queries", "lock_data"),
    system_admin = c("manage_users", "system_config", "database_backup"),
    principal_investigator = c("view_all_data", "approve_protocol_deviations", "final_approval"),
    monitor = c("view_all_data", "generate_monitoring_reports", "create_findings"),
    biostatistician = c("view_locked_data", "generate_analysis_datasets", "statistical_reports")
  )

  # Check user permissions
  check_permission <- function(user_id, required_permission) {
    # Get user role
    role_query <- "SELECT role FROM users WHERE user_id = ?"
    user_role <- pool::dbGetQuery(db_pool, role_query, params = list(user_id))$role

    # Check if role has required permission
    role_permissions <- permissions[[user_role]]
    return(required_permission %in% role_permissions)
  }

  # Permission decorator for functions
  require_permission <- function(permission) {
    function(f) {
      function(...) {
        current_user <- get_current_user() # From session
        if (!check_permission(current_user$user_id, permission)) {
          stop("Access denied: insufficient permissions")
        }
        f(...)
      }
    }
  }

  # Example usage
  delete_subject_data <- require_permission("edit_all_data")(function(subject_id) {
    # Function implementation
    pool::dbExecute(db_pool, "DELETE FROM subjects WHERE subject_id = ?",
                   params = list(subject_id))
  })
}
```

### Audit Trail and Compliance

```{r audit_compliance}
# Comprehensive audit logging
audit_system <- function() {

  # Log all database operations
  log_database_operation <- function(user_id, operation, table_name, record_id, old_values = NULL, new_values = NULL) {

    audit_entry <- list(
      timestamp = Sys.time(),
      user_id = user_id,
      operation = operation, # INSERT, UPDATE, DELETE, SELECT
      table_name = table_name,
      record_id = record_id,
      old_values = if(!is.null(old_values)) jsonlite::toJSON(old_values) else NULL,
      new_values = if(!is.null(new_values)) jsonlite::toJSON(new_values) else NULL,
      ip_address = get_client_ip(),
      user_agent = get_user_agent()
    )

    pool::dbExecute(db_pool,
      "INSERT INTO audit_log (timestamp, user_id, operation, table_name, record_id, old_values, new_values, ip_address, user_agent)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
      params = audit_entry
    )
  }

  # Audit report generation
  generate_audit_report <- function(start_date, end_date, user_id = NULL, table_name = NULL) {

    base_query <- "
      SELECT
        al.timestamp,
        u.username,
        al.operation,
        al.table_name,
        al.record_id,
        al.old_values,
        al.new_values,
        al.ip_address
      FROM audit_log al
      JOIN users u ON al.user_id = u.user_id
      WHERE al.timestamp BETWEEN ? AND ?
    "

    params <- list(start_date, end_date)

    if (!is.null(user_id)) {
      base_query <- paste(base_query, "AND al.user_id = ?")
      params <- append(params, user_id)
    }

    if (!is.null(table_name)) {
      base_query <- paste(base_query, "AND al.table_name = ?")
      params <- append(params, table_name)
    }

    base_query <- paste(base_query, "ORDER BY al.timestamp DESC")

    result <- pool::dbGetQuery(db_pool, base_query, params = params)
    return(result)
  }

  # Data integrity checks
  verify_data_integrity <- function() {

    integrity_checks <- list()

    # Check for orphaned records
    orphan_check <- "
      SELECT 'visits' as table_name, COUNT(*) as orphan_count
      FROM visits v
      LEFT JOIN subjects s ON v.subject_id = s.subject_id
      WHERE s.subject_id IS NULL
    "

    integrity_checks$orphaned_visits <- pool::dbGetQuery(db_pool, orphan_check)

    # Check for duplicate subjects
    duplicate_check <- "
      SELECT subject_id, COUNT(*) as count
      FROM subjects
      GROUP BY subject_id
      HAVING COUNT(*) > 1
    "

    integrity_checks$duplicate_subjects <- pool::dbGetQuery(db_pool, duplicate_check)

    # Check for invalid date ranges
    date_check <- "
      SELECT subject_id, enrollment_date, completion_date
      FROM subjects
      WHERE completion_date < enrollment_date
    "

    integrity_checks$invalid_dates <- pool::dbGetQuery(db_pool, date_check)

    return(integrity_checks)
  }
}

# 21 CFR Part 11 compliance features
cfr_part11_compliance <- function() {

  # Electronic signature system
  electronic_signature <- function(user_id, document_id, signature_meaning) {

    # Generate signature hash
    signature_data <- list(
      user_id = user_id,
      document_id = document_id,
      timestamp = Sys.time(),
      meaning = signature_meaning
    )

    signature_hash <- digest::digest(jsonlite::toJSON(signature_data), algo = "sha256")

    # Store signature
    pool::dbExecute(db_pool,
      "INSERT INTO electronic_signatures (user_id, document_id, signature_hash, signature_meaning, timestamp)
       VALUES (?, ?, ?, ?, ?)",
      params = list(user_id, document_id, signature_hash, signature_meaning, Sys.time())
    )

    # Log the signing event
    log_database_operation(user_id, "SIGN", "electronic_signatures", document_id)

    return(signature_hash)
  }

  # Document version control
  version_control <- function() {

    create_document_version <- function(document_id, content, version_comment) {
      # Calculate content hash
      content_hash <- digest::digest(content, algo = "sha256")

      # Get next version number
      version_query <- "SELECT COALESCE(MAX(version_number), 0) + 1 as next_version
                      FROM document_versions WHERE document_id = ?"
      next_version <- pool::dbGetQuery(db_pool, version_query, params = list(document_id))$next_version

      # Store version
      pool::dbExecute(db_pool,
        "INSERT INTO document_versions (document_id, version_number, content, content_hash, version_comment, created_timestamp)
         VALUES (?, ?, ?, ?, ?, ?)",
        params = list(document_id, next_version, content, content_hash, version_comment, Sys.time())
      )

      return(next_version)
    }

    get_document_history <- function(document_id) {
      history_query <- "
        SELECT
          dv.version_number,
          dv.content_hash,
          dv.version_comment,
          dv.created_timestamp,
          u.username as created_by
        FROM document_versions dv
        JOIN users u ON dv.created_by = u.user_id
        WHERE dv.document_id = ?
        ORDER BY dv.version_number DESC
      "

      return(pool::dbGetQuery(db_pool, history_query, params = list(document_id)))
    }
  }
}
```

## Performance Optimization

### Database Optimization

```{r db_optimization}
# Database performance tuning
optimize_database <- function() {

  # Create indexes for frequently queried columns
  create_indexes <- function() {
    indexes <- c(
      "CREATE INDEX IF NOT EXISTS idx_subjects_site_id ON subjects(site_id)",
      "CREATE INDEX IF NOT EXISTS idx_subjects_enrollment_date ON subjects(enrollment_date)",
      "CREATE INDEX IF NOT EXISTS idx_visits_subject_id ON visits(subject_id)",
      "CREATE INDEX IF NOT EXISTS idx_visits_visit_date ON visits(visit_date)",
      "CREATE INDEX IF NOT EXISTS idx_adverse_events_subject_id ON adverse_events(subject_id)",
      "CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp ON audit_log(timestamp)",
      "CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id)"
    )

    for (index in indexes) {
      pool::dbExecute(db_pool, index)
    }
  }

  # Database maintenance
  database_maintenance <- function() {
    # Vacuum database to reclaim space
    pool::dbExecute(db_pool, "VACUUM")

    # Analyze tables for query optimization
    pool::dbExecute(db_pool, "ANALYZE")

    # Check database integrity
    integrity_result <- pool::dbGetQuery(db_pool, "PRAGMA integrity_check")

    return(integrity_result)
  }

  # Query optimization
  optimized_queries <- function() {

    # Efficient subject listing with pagination
    get_subjects_paginated <- function(page = 1, page_size = 50, site_id = NULL) {
      offset <- (page - 1) * page_size

      base_query <- "
        SELECT
          subject_id,
          initials,
          enrollment_date,
          status,
          site_id
        FROM subjects
      "

      params <- list()

      if (!is.null(site_id)) {
        base_query <- paste(base_query, "WHERE site_id = ?")
        params <- list(site_id)
      }

      base_query <- paste(base_query, "ORDER BY enrollment_date DESC LIMIT ? OFFSET ?")
      params <- append(params, list(page_size, offset))

      return(pool::dbGetQuery(db_pool, base_query, params = params))
    }

    # Efficient dashboard statistics
    get_dashboard_stats <- function() {
      stats_query <- "
        WITH subject_stats AS (
          SELECT
            COUNT(*) as total_subjects,
            COUNT(CASE WHEN status = 'Active' THEN 1 END) as active_subjects,
            COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed_subjects,
            COUNT(CASE WHEN status = 'Withdrawn' THEN 1 END) as withdrawn_subjects
          FROM subjects
        ),
        visit_stats AS (
          SELECT
            COUNT(*) as total_visits,
            COUNT(CASE WHEN visit_status = 'Completed' THEN 1 END) as completed_visits
          FROM visits
        ),
        ae_stats AS (
          SELECT
            COUNT(*) as total_aes,
            COUNT(CASE WHEN serious = 1 THEN 1 END) as serious_aes
          FROM adverse_events
        )
        SELECT * FROM subject_stats, visit_stats, ae_stats
      "

      return(pool::dbGetQuery(db_pool, stats_query))
    }
  }
}

# Application performance monitoring
performance_monitoring <- function() {

  # Query execution time tracking
  track_query_performance <- function(query, params = NULL) {
    start_time <- Sys.time()

    result <- pool::dbGetQuery(db_pool, query, params = params)

    end_time <- Sys.time()
    execution_time <- as.numeric(end_time - start_time)

    # Log slow queries
    if (execution_time > 1.0) { # Log queries taking more than 1 second
      pool::dbExecute(db_pool,
        "INSERT INTO slow_query_log (query_text, execution_time, timestamp) VALUES (?, ?, ?)",
        params = list(query, execution_time, Sys.time())
      )
    }

    return(result)
  }

  # Memory usage monitoring
  monitor_memory_usage <- function() {
    gc_info <- gc()
    memory_usage <- list(
      used_mb = sum(gc_info[, "used"]) * 0.001,
      max_mb = sum(gc_info[, "max used"]) * 0.001,
      timestamp = Sys.time()
    )

    return(memory_usage)
  }

  # Session monitoring
  monitor_sessions <- function() {
    session_info <- list(
      active_sessions = length(ls(envir = .GlobalEnv, pattern = "session_")),
      total_connections = pool::dbGetInfo(db_pool)$connections,
      memory_usage = monitor_memory_usage(),
      timestamp = Sys.time()
    )

    return(session_info)
  }
}
```

## Enterprise Deployment

### Docker Configuration

```{r docker_deploy}
# Docker deployment configuration
create_dockerfile <- function() {
  dockerfile_content <- '
FROM rocker/shiny:latest

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    libssl-dev \\
    libcurl4-gnutls-dev \\
    libxml2-dev \\
    libsqlite3-dev

# Install R packages
RUN R -e "install.packages(c(\'shiny\', \'bslib\', \'DT\', \'pool\', \'RSQLite\', \'config\', \'digest\'))"

# Copy application files
COPY . /srv/shiny-server/zzedc/

# Set permissions
RUN chown -R shiny:shiny /srv/shiny-server/zzedc/

# Create data directory with proper permissions
RUN mkdir -p /srv/shiny-server/zzedc/data && \\
    chown -R shiny:shiny /srv/shiny-server/zzedc/data

# Expose port
EXPOSE 3838

# Run application
CMD ["/usr/bin/shiny-server"]
'

  writeLines(dockerfile_content, "Dockerfile")
}

# Docker Compose for full stack
create_docker_compose <- function() {
  compose_content <- '
version: "3.8"

services:
  zzedc-app:
    build: .
    container_name: zzedc-application
    ports:
      - "3838:3838"
    volumes:
      - ./data:/srv/shiny-server/zzedc/data
      - ./logs:/srv/shiny-server/zzedc/logs
    environment:
      - ZZEDC_ENV=production
      - ZZEDC_DB_PATH=/srv/shiny-server/zzedc/data/production.db
    depends_on:
      - zzedc-db
    restart: unless-stopped

  zzedc-db:
    image: postgres:13
    container_name: zzedc-database
    environment:
      POSTGRES_DB: zzedc_production
      POSTGRES_USER: zzedc_user
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  zzedc-nginx:
    image: nginx:alpine
    container_name: zzedc-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - zzedc-app
    restart: unless-stopped

volumes:
  postgres_data:
'

  writeLines(compose_content, "docker-compose.yml")
}
```

### Load Balancing and Scaling

```{r scaling}
# Horizontal scaling configuration
setup_load_balancing <- function() {

  # Nginx configuration for load balancing
  nginx_config <- '
upstream zzedc_backend {
    least_conn;
    server zzedc-app-1:3838 max_fails=3 fail_timeout=30s;
    server zzedc-app-2:3838 max_fails=3 fail_timeout=30s;
    server zzedc-app-3:3838 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://zzedc_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeout settings
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
'

  writeLines(nginx_config, "nginx.conf")
}

# Session management for scaled deployment
distributed_session_management <- function() {

  # Redis-based session storage
  setup_redis_sessions <- function() {

    # Session storage functions
    store_session <- function(session_id, session_data) {
      redis_conn <- redux::hiredis()
      redis_conn$SET(paste0("session:", session_id),
                    jsonlite::toJSON(session_data))
      redis_conn$EXPIRE(paste0("session:", session_id), 3600) # 1 hour expiry
    }

    retrieve_session <- function(session_id) {
      redis_conn <- redux::hiredis()
      session_json <- redis_conn$GET(paste0("session:", session_id))

      if (is.null(session_json)) {
        return(NULL)
      }

      return(jsonlite::fromJSON(session_json))
    }

    invalidate_session <- function(session_id) {
      redis_conn <- redux::hiredis()
      redis_conn$DEL(paste0("session:", session_id))
    }
  }
}
```

## Integration Examples

### Laboratory Data Integration

```{r lab_integration}
# Laboratory information system integration
lab_integration <- function() {

  # HL7 message parsing
  parse_hl7_message <- function(hl7_message) {

    # Simple HL7 parser (in production, use dedicated HL7 library)
    segments <- strsplit(hl7_message, "\r")[[1]]

    parsed_data <- list()

    for (segment in segments) {
      fields <- strsplit(segment, "\\|")[[1]]

      if (length(fields) > 0) {
        segment_type <- fields[1]

        if (segment_type == "OBR") {
          # Observation request
          parsed_data$order_id <- fields[4]
          parsed_data$test_requested <- fields[5]
        } else if (segment_type == "OBX") {
          # Observation result
          parsed_data$results <- append(parsed_data$results, list(
            test_id = fields[4],
            value = fields[6],
            units = fields[7],
            reference_range = fields[8]
          ))
        }
      }
    }

    return(parsed_data)
  }

  # Automatic lab data import
  import_lab_results <- function(lab_file_path) {

    # Read lab data file
    lab_data <- read.csv(lab_file_path)

    # Validate and standardize
    standardized_data <- lab_data %>%
      mutate(
        subject_id = toupper(trimws(subject_id)),
        collection_date = as.Date(collection_date),
        result_value = as.numeric(result_value)
      ) %>%
      filter(
        !is.na(subject_id),
        !is.na(collection_date),
        !is.na(result_value)
      )

    # Insert into database
    for (i in 1:nrow(standardized_data)) {
      row <- standardized_data[i, ]

      pool::dbExecute(db_pool,
        "INSERT INTO laboratory_results
         (subject_id, test_name, result_value, units, collection_date, import_timestamp)
         VALUES (?, ?, ?, ?, ?, ?)",
        params = list(
          row$subject_id,
          row$test_name,
          row$result_value,
          row$units,
          row$collection_date,
          Sys.time()
        )
      )
    }

    return(nrow(standardized_data))
  }
}
```

## Custom Validation Rules

```{r custom_validation}
# Advanced validation system
advanced_validation <- function() {

  # Rule-based validation engine
  validation_engine <- function() {

    # Define validation rules
    validation_rules <- list(
      age_range = function(age) {
        if (is.na(age) || age < 18 || age > 100) {
          return("Age must be between 18 and 100")
        }
        return(NULL)
      },

      visit_window = function(enrollment_date, visit_date, window_days = 30) {
        if (is.na(enrollment_date) || is.na(visit_date)) {
          return("Both enrollment and visit dates required")
        }

        days_diff <- as.numeric(visit_date - enrollment_date)
        if (days_diff < 0 || days_diff > window_days) {
          return(paste("Visit must be within", window_days, "days of enrollment"))
        }
        return(NULL)
      },

      lab_value_range = function(test_name, value) {
        ranges <- list(
          "Hemoglobin" = c(8, 18),
          "Glucose" = c(70, 400),
          "Creatinine" = c(0.5, 3.0)
        )

        if (!test_name %in% names(ranges)) {
          return(paste("Unknown test:", test_name))
        }

        range <- ranges[[test_name]]
        if (is.na(value) || value < range[1] || value > range[2]) {
          return(paste(test_name, "must be between", range[1], "and", range[2]))
        }
        return(NULL)
      }
    )

    # Execute validation
    validate_record <- function(record, rules_to_apply) {
      errors <- c()

      for (rule_name in rules_to_apply) {
        if (rule_name %in% names(validation_rules)) {
          rule_function <- validation_rules[[rule_name]]

          # Apply rule based on record type
          if (rule_name == "age_range") {
            error <- rule_function(record$age)
          } else if (rule_name == "visit_window") {
            error <- rule_function(record$enrollment_date, record$visit_date)
          } else if (rule_name == "lab_value_range") {
            error <- rule_function(record$test_name, record$result_value)
          }

          if (!is.null(error)) {
            errors <- c(errors, error)
          }
        }
      }

      return(errors)
    }

    return(list(
      rules = validation_rules,
      validate = validate_record
    ))
  }

  # Cross-record validation
  cross_validation <- function() {

    # Check for logical inconsistencies across visits
    validate_visit_sequence <- function(subject_id) {
      visits_query <- "
        SELECT visit_date, visit_type
        FROM visits
        WHERE subject_id = ?
        ORDER BY visit_date
      "

      visits <- pool::dbGetQuery(db_pool, visits_query, params = list(subject_id))

      errors <- c()

      # Check that screening comes before baseline
      screening_date <- visits[visits$visit_type == "Screening", "visit_date"]
      baseline_date <- visits[visits$visit_type == "Baseline", "visit_date"]

      if (length(screening_date) > 0 && length(baseline_date) > 0) {
        if (baseline_date <= screening_date) {
          errors <- c(errors, "Baseline visit must occur after screening")
        }
      }

      return(errors)
    }
  }
}
```

This completes the advanced features vignette, covering custom modules, APIs, security, performance optimization, enterprise deployment, and integration capabilities. These features enable ZZedc to scale from simple studies to complex, multi-site clinical trials with enterprise-grade requirements.

## Support and Resources

For implementing advanced features:

- **Custom Development**: Contact for consulting services
- **Enterprise Support**: Available for large deployments
- **Training**: Advanced user training programs available
- **Integration Services**: Custom integration development

**Contact Information:**
- Email: rgthomas@ucsd.edu
- GitHub: https://github.com/rgt47/zzedc
- Enterprise Inquiries: Available upon request